{"version":3,"sources":["webpack://typedjson/webpack/universalModuleDefinition","webpack://typedjson/webpack/bootstrap","webpack://typedjson/./src/typedjson/helpers.ts","webpack://typedjson/./src/typedjson/metadata.ts","webpack://typedjson/./src/typedjson/options-base.ts","webpack://typedjson/./src/typedjson/type-descriptor.ts","webpack://typedjson/./src/typedjson/serializer.ts","webpack://typedjson/./src/typedjson/deserializer.ts","webpack://typedjson/./src/typedjson/json-array-member.ts","webpack://typedjson/./src/parser.ts","webpack://typedjson/./src/typedjson/json-object.ts","webpack://typedjson/./src/typedjson/json-member.ts","webpack://typedjson/./src/typedjson/json-set-member.ts","webpack://typedjson/./src/typedjson/json-map-member.ts","webpack://typedjson/./src/typedjson/to-json.ts","webpack://typedjson/./src/typedjson.ts"],"names":[],"mappings":"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","file":"typedjson.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"typedjson\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"typedjson\"] = factory();\n\telse\n\t\troot[\"typedjson\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","declare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport const METADATA_FIELD_KEY = \"__typedJsonJsonObjectMetadataInformation__\";\n\nexport const MISSING_REFLECT_CONF_MSG = 'Are you sure, that you have both \"experimentalDecorators\"' +\n    ' and \"emitDecoratorMetadata\" in your tsconfig.json?';\n\nexport function getDefaultValue<T>(type: { new (): T }): T|undefined\n{\n    switch (type as any)\n    {\n        case Number:\n            return 0 as any;\n\n        case String:\n            return \"\" as any;\n\n        case Boolean:\n            return false as any;\n\n        case Array:\n            return [] as any;\n\n        default:\n            return undefined;\n    }\n}\n\n/**\n * Determines whether the specified type is a type that can be passed on \"as-is\" into `JSON.stringify`.\n * Values of these types don't need special conversion.\n * @param type The constructor of the type (wrapper constructor for primitive types, e.g. `Number` for `number`).\n */\nexport function isDirectlySerializableNativeType(type: Function): boolean\n{\n    return !!(~[Date, Number, String, Boolean].indexOf(type as any));\n}\n\nexport function isDirectlyDeserializableNativeType(type: Function): boolean\n{\n    return !!(~[Number, String, Boolean].indexOf(type as any));\n}\n\nexport function isTypeTypedArray(type: Function): boolean\n{\n    return !!(~[Float32Array, Float64Array, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array]\n        .indexOf(type as any));\n}\n\nexport function isPrimitiveValue(obj: any): boolean\n{\n    switch (typeof obj)\n    {\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n            return true;\n        default:\n            return (obj instanceof String || obj instanceof Number || obj instanceof Boolean);\n    }\n}\n\nexport function isObject(value: any): value is Object\n{\n    return typeof value === \"object\";\n}\n\nfunction shouldOmitParseString(jsonStr: string, expectedType: Function): boolean {\n    const expectsTypesSerializedAsStrings = expectedType === String\n        || expectedType === ArrayBuffer\n        || expectedType === DataView;\n\n    const hasQuotes = jsonStr.length >= 2 && jsonStr[0] === '\"' && jsonStr[jsonStr.length-1] === '\"';\n    const isInteger = /^\\d+$/.test(jsonStr.trim());\n\n    return (expectsTypesSerializedAsStrings && !hasQuotes) || ((!hasQuotes && !isInteger) && expectedType === Date);\n}\n\nexport function parseToJSObject(json: any, expectedType: Function): Object {\n    if (typeof json !== 'string' || shouldOmitParseString(json, expectedType))\n    {\n      return json;\n    }\n    return JSON.parse(json);\n}\n\n/**\n * Determines if 'A' is a sub-type of 'B' (or if 'A' equals 'B').\n * @param A The supposed derived type.\n * @param B The supposed base type.\n */\nexport function isSubtypeOf(A: Function, B: Function)\n{\n    return A === B || A.prototype instanceof B;\n}\n\nexport function logError(message?: any, ...optionalParams: any[])\n{\n    if (typeof console === \"object\" && typeof console.error === \"function\")\n    {\n        console.error(message, ...optionalParams);\n    }\n    else if (typeof console === \"object\" && typeof console.log === \"function\")\n    {\n        console.log(`ERROR: ${message}`, ...optionalParams);\n    }\n}\n\nexport function logMessage(message?: any, ...optionalParams: any[])\n{\n    if (typeof console === \"object\" && typeof console.log === \"function\")\n    {\n        console.log(message, ...optionalParams);\n    }\n}\n\nexport function logWarning(message?: any, ...optionalParams: any[])\n{\n    if (typeof console === \"object\" && typeof console.warn === \"function\")\n    {\n        console.warn(message, ...optionalParams);\n    }\n    else if (typeof console === \"object\" && typeof console.log === \"function\")\n    {\n        console.log(`WARNING: ${message}`, ...optionalParams);\n    }\n}\n\n/**\n * Checks if the value is considered defined (not undefined and not null).\n * @param value\n */\nexport function isValueDefined<T>(value: T): value is Exclude<T, undefined | null>\n{\n    return !(typeof value === \"undefined\" || value === null);\n}\n\nexport function isInstanceOf<T>(value: any, constructor: Function): boolean\n{\n    if (typeof value === \"number\")\n    {\n        return (constructor === Number);\n    }\n    else if (typeof value === \"string\")\n    {\n        return (constructor === String);\n    }\n    else if (typeof value === \"boolean\")\n    {\n        return (constructor === Boolean);\n    }\n    else if (isObject(value))\n    {\n        return (value instanceof constructor);\n    }\n\n    return false;\n}\n\nexport const isReflectMetadataSupported =\n    (typeof Reflect === \"object\" && typeof Reflect.getMetadata === \"function\");\n\n/**\n * Gets the name of a function.\n * @param fn The function whose name to get.\n */\nexport function nameof(fn: Function & { name?: string })\n{\n    if (typeof fn.name === \"string\")\n    {\n        return fn.name;\n    }\n    return \"undefined\";\n}\n","import { nameof, logError, METADATA_FIELD_KEY, isDirectlySerializableNativeType, isTypeTypedArray } from \"./helpers\";\nimport { IndexedObject } from \"./types\";\nimport { OptionsBase } from \"./options-base\";\nimport { TypeDescriptor } from \"./type-descriptor\";\n\nexport interface JsonMemberMetadata\n{\n    /** If set, a default value will be emitted for uninitialized members. */\n    emitDefaultValue?: boolean;\n\n    /** Member name as it appears in the serialized JSON. */\n    name: string;\n\n    /** Property or field key of the json member. */\n    key: string;\n\n    /** Constuctor (type) reference of the member. */\n    type?: TypeDescriptor;\n\n    /** If set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    options?: OptionsBase;\n\n    /** Custom deserializer to use. */\n    deserializer?: (json: any) => any;\n\n    /** Custom serializer to use. */\n    serializer?: (value: any) => any;\n}\n\nexport class JsonObjectMetadata\n{\n    //#region Static\n    /**\n     * Gets the name of a class as it appears in a serialized JSON string.\n     * @param ctor The constructor of a class (with or without jsonObject).\n     */\n    public static getJsonObjectName(ctor: Function): string\n    {\n        const metadata = JsonObjectMetadata.getFromConstructor(ctor);\n        return metadata ? nameof(metadata.classType) : nameof(ctor);\n    }\n\n    /**\n     * Gets jsonObject metadata information from a class.\n     * @param ctor The constructor class.\n     */\n    public static getFromConstructor(ctor: Function): JsonObjectMetadata|undefined\n    {\n        const prototype = ctor.prototype;\n        if (!prototype)\n        {\n            return;\n        }\n\n        let metadata: JsonObjectMetadata|undefined;\n        if (prototype.hasOwnProperty(METADATA_FIELD_KEY))\n        {\n            // The class prototype contains own jsonObject metadata\n            metadata = prototype[METADATA_FIELD_KEY];\n        }\n\n        // Ignore implicitly added jsonObject (through jsonMember)\n        if (metadata && metadata.isExplicitlyMarked)\n        {\n            return metadata;\n        }\n\n        // In the end maybe it is something which we can handle directly\n        if (JsonObjectMetadata.doesHandleWithoutAnnotation(ctor))\n        {\n            const primitiveMeta = new JsonObjectMetadata(ctor);\n            primitiveMeta.isExplicitlyMarked = true;\n            // we do not store the metadata here to not modify builtin prototype\n            return primitiveMeta;\n        }\n    }\n\n    /**\n     * Gets the known type name of a jsonObject class for type hint.\n     * @param constructor The constructor class.\n     */\n    public static getKnownTypeNameFromType(constructor: Function): string\n    {\n        const metadata = JsonObjectMetadata.getFromConstructor(constructor);\n        return metadata ? nameof(metadata.classType) : nameof(constructor);\n    }\n\n    private static doesHandleWithoutAnnotation(ctor: Function): boolean\n    {\n        return isDirectlySerializableNativeType(ctor) || isTypeTypedArray(ctor)\n            || ctor === DataView || ctor === ArrayBuffer;\n    }\n    //#endregion\n\n    constructor(\n        classType: Function,\n    ) {\n        this.classType = classType;\n    }\n\n    public dataMembers: Map<string, JsonMemberMetadata> = new Map<string, JsonMemberMetadata>();\n\n    public knownTypes: Set<Function> = new Set<Function>();\n\n    public knownTypeMethodName?: string;\n\n    /** Gets or sets the constructor function for the jsonObject. */\n    public classType: Function;\n\n    /**\n     * Indicates whether this class was explicitly annotated with @jsonObject\n     * or implicitly by @jsonMember\n     */\n    public isExplicitlyMarked: boolean = false;\n\n    /**\n     * Indicates whether this type is handled without annotation. This is usually\n     * used for the builtin types (except for Maps, Sets, and normal Arrays).\n     */\n    public isHandledWithoutAnnotation: boolean = false;\n\n    /** Name used to encode polymorphic type */\n    public name?: string;\n\n    public options?: OptionsBase;\n\n    public onDeserializedMethodName?: string;\n\n    public beforeSerializationMethodName?: string;\n\n    public initializerCallback?: (sourceObject: Object, rawSourceObject: Object) => Object;\n}\n\nexport function injectMetadataInformation(constructor: IndexedObject, propKey: string | symbol, metadata: JsonMemberMetadata)\n{\n    const decoratorName = `@jsonMember on ${nameof(constructor.constructor)}.${String(propKey)}`; // For error messages.\n    let objectMetadata: JsonObjectMetadata;\n\n    // When a property decorator is applied to a static member, 'constructor' is a constructor function.\n    // See: https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Decorators.md#property-decorators\n    // ... and static members are not supported here, so abort.\n    if (typeof constructor === \"function\")\n    {\n        logError(`${decoratorName}: cannot use a static property.`);\n        return;\n    }\n\n    // Methods cannot be serialized.\n    // @ts-ignore symbol indexing is not supported by ts\n    if (typeof constructor[propKey] === \"function\")\n    {\n        logError(`${decoratorName}: cannot use a method property.`);\n        return;\n    }\n\n    if (!metadata || (!metadata.type && !metadata.deserializer))\n    {\n        logError(`${decoratorName}: JsonMemberMetadata has unknown type.`);\n        return;\n    }\n\n    // Add jsonObject metadata to 'constructor' if not yet exists ('constructor' is the prototype).\n    // NOTE: this will not fire up custom serialization, as 'constructor' must be explicitly marked with '@jsonObject' as well.\n    if (!constructor.hasOwnProperty(METADATA_FIELD_KEY))\n    {\n        // No *own* metadata, create new.\n        objectMetadata = new JsonObjectMetadata(constructor.constructor);\n\n        // Inherit @JsonMembers from parent @jsonObject (if any).\n        const parentMetadata: JsonObjectMetadata = constructor[METADATA_FIELD_KEY];\n        if (parentMetadata) // && !constructor.hasOwnProperty(Helpers.METADATA_FIELD_KEY)\n        {\n            parentMetadata.dataMembers.forEach((_metadata, _propKey) => objectMetadata.dataMembers.set(_propKey, _metadata));\n        }\n\n        // ('constructor' is the prototype of the involved class, metadata information is added to this class prototype).\n        Object.defineProperty(constructor, METADATA_FIELD_KEY, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: objectMetadata\n        });\n    }\n    else\n    {\n        // JsonObjectMetadata already exists on 'constructor'.\n        objectMetadata = constructor[METADATA_FIELD_KEY];\n    }\n\n    if (!metadata.deserializer)\n    {\n        // @ts-ignore above is a check (!deser && !ctor)\n        metadata.type.getTypes().forEach(ctor => objectMetadata.knownTypes.add(ctor));\n    }\n\n    // clear metadata of undefined properties to save memory\n    (Object.keys(metadata) as [keyof JsonMemberMetadata])\n        .forEach((key) => (metadata[key] === undefined) && delete metadata[key]);\n    objectMetadata.dataMembers.set(metadata.name, metadata);\n}\n","/**\n * This options cascade through the annotations. Options set\n * in the more specific place override the previous option.\n * Ex. @jsonMember overrides TypedJson options.\n */\nexport interface OptionsBase {\n    /**\n     * Whether to preserve null in the JSON output. When false it\n     * will not emit nor store the property if its value is null.\n     * Default: false.\n     */\n    preserveNull?: boolean;\n}\n\nconst kAllOptions: (keyof OptionsBase)[] = [\n    'preserveNull',\n];\n\nexport function extractOptionBase(from: {[key: string]: any} & OptionsBase): OptionsBase|undefined {\n    const options = Object.keys(from)\n        .filter(key => (kAllOptions as string[]).indexOf(key) > -1)\n        .reduce((obj, key) => {\n            obj[key] = from[key];\n            return obj;\n        }, {} as any);\n    return Object.keys(options).length > 0 ? options : undefined;\n}\n\nexport function getDefaultOptionOf<K extends keyof OptionsBase>(key: K): Required<OptionsBase>[K] {\n    switch (key) {\n        case \"preserveNull\":\n            return false;\n    }\n    // never reached\n    return null as any;\n}\n\nexport function getOptionValue<K extends keyof OptionsBase>(\n    key: K,\n    options?: OptionsBase,\n): Required<OptionsBase>[K] {\n    if (options && options[key] != null) return options[key]!;\n    return getDefaultOptionOf(key);\n}\n\nexport function mergeOptions(\n    existing?: OptionsBase,\n    moreSpecific?: OptionsBase,\n): OptionsBase|undefined {\n    return !moreSpecific\n        ? existing\n        : Object.assign(\n            {},\n            existing,\n            moreSpecific,\n        );\n}\n","export abstract class TypeDescriptor {\n    protected constructor(public readonly ctor: Function) {}\n\n    getTypes(): Function[] {\n        return [this.ctor];\n    }\n}\n\nexport type Typelike = TypeDescriptor|Function;\n\nexport class ConcreteTypeDescriptor extends TypeDescriptor {\n    constructor(ctor: Function) {\n        super(ctor);\n    }\n}\n\nexport abstract class GenericTypeDescriptor extends TypeDescriptor {\n    protected constructor(ctor: Function) {\n        super(ctor);\n    }\n}\n\nexport class ArrayTypeDescriptor extends GenericTypeDescriptor {\n    constructor(public readonly elementType: TypeDescriptor) {\n        super(Array);\n    }\n\n    getTypes(): Function[] {\n        return super.getTypes().concat(this.elementType.getTypes());\n    }\n}\n\nexport function ArrayT(elementType: Typelike): ArrayTypeDescriptor {\n    return new ArrayTypeDescriptor(ensureTypeDescriptor(elementType));\n}\n\nexport class SetTypeDescriptor extends GenericTypeDescriptor {\n    constructor(public readonly elementType: TypeDescriptor) {\n        super(Set);\n    }\n\n    getTypes(): Function[] {\n        return super.getTypes().concat(this.elementType.getTypes());\n    }\n}\n\nexport function SetT(elementType: Typelike): SetTypeDescriptor {\n    return new SetTypeDescriptor(ensureTypeDescriptor(elementType));\n}\n\nexport class MapTypeDescriptor extends GenericTypeDescriptor {\n    constructor(\n        public readonly keyType: TypeDescriptor,\n        public readonly valueType: TypeDescriptor,\n    ) {\n        super(Map);\n    }\n\n    getTypes(): Function[] {\n        return super.getTypes().concat(this.keyType.getTypes(), this.valueType.getTypes());\n    }\n}\n\nexport function MapT(keyType: Typelike, valueType: Typelike): MapTypeDescriptor {\n    return new MapTypeDescriptor(ensureTypeDescriptor(keyType), ensureTypeDescriptor(valueType));\n}\n\n// export class DictionaryTypeDescriptor extends GenericTypeDescriptor {\n//     constructor(public readonly elementType: TypeDescriptor) {\n//         super(Object);\n//     }\n//\n//     getTypes(): Function[] {\n//         return super.getTypes().concat(this.elementType.getTypes());\n//     }\n// }\n//\n// export function DictT(elementType: Typelike): DictionaryTypeDescriptor {\n//     return new DictionaryTypeDescriptor(ensureTypeDescriptor(elementType));\n// }\n\nexport function isTypelike(type: any): type is Typelike {\n    return type && (typeof type === \"function\" || type instanceof TypeDescriptor);\n}\n\nexport function ensureTypeDescriptor(type: Typelike): TypeDescriptor {\n    return type instanceof TypeDescriptor ? type : new ConcreteTypeDescriptor(type);\n}\n","import {\n    isDirectlySerializableNativeType,\n    isInstanceOf,\n    isTypeTypedArray,\n    isValueDefined,\n    logError,\n    nameof,\n} from \"./helpers\";\nimport { IndexedObject } from \"./types\";\nimport { JsonObjectMetadata } from \"./metadata\";\nimport { getOptionValue, mergeOptions, OptionsBase } from \"./options-base\";\nimport {\n    ArrayTypeDescriptor,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from \"./type-descriptor\";\n\nexport interface IScopeTypeInfo\n{\n    type: TypeDescriptor;\n}\n\nexport type TypeHintEmitter\n    = (\n        targetObject: IndexedObject,\n        sourceObject: IndexedObject,\n        expectedSourceType: Function,\n        sourceTypeMetadata?: JsonObjectMetadata,\n    ) => void;\n\nfunction defaultTypeEmitter(\n    targetObject: IndexedObject,\n    sourceObject: IndexedObject,\n    expectedSourceType: Function,\n    sourceTypeMetadata?: JsonObjectMetadata,\n) {\n    // By default, we put a \"__type\" property on the output object if the actual object is not the\n    // same as the expected one, so that deserialization will know what to deserialize into (given\n    // the required known-types are defined, and the object is a valid subtype of the expected type).\n    if (sourceObject.constructor !== expectedSourceType)\n    {\n        targetObject.__type = sourceTypeMetadata && sourceTypeMetadata.name\n            ? sourceTypeMetadata.name\n            : nameof(sourceObject.constructor);\n    }\n}\n\n/**\n * Utility class, converts a typed object tree (i.e. a tree of class instances, arrays of class\n * instances, and so on) to an untyped javascript object (also called \"simple javascript object\"),\n * and emits any necessary type hints in the process (for polymorphism).\n *\n * The converted object tree is what will be given to `JSON.stringify` to convert to string as the\n * last step, the serialization is basically like:\n *\n * (1) typed object-tree -> (2) simple JS object-tree -> (3) JSON-string\n */\nexport class Serializer\n{\n    public options?: OptionsBase;\n    private _typeHintEmitter: TypeHintEmitter = defaultTypeEmitter;\n    private _errorHandler: (error: Error) => void = logError;\n\n    public setTypeHintEmitter(typeEmitterCallback: TypeHintEmitter)\n    {\n        if (typeof typeEmitterCallback !== \"function\")\n        {\n            throw new TypeError(\"'typeEmitterCallback' is not a function.\");\n        }\n\n        this._typeHintEmitter = typeEmitterCallback;\n    }\n\n    public setErrorHandler(errorHandlerCallback: (error: Error) => void)\n    {\n        if (typeof errorHandlerCallback !== \"function\")\n        {\n            throw new TypeError(\"'errorHandlerCallback' is not a function.\");\n        }\n\n        this._errorHandler = errorHandlerCallback;\n    }\n\n    /**\n     * Convert a value of any supported serializable type.\n     * The value type will be detected, and the correct serialization method will be called.\n     */\n    public convertSingleValue(\n        sourceObject: any,\n        typeInfo: IScopeTypeInfo,\n        memberName: string = \"object\",\n        memberOptions?: OptionsBase,\n    ): any {\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null) return null;\n        if (!isValueDefined(sourceObject)) return;\n\n        if (!isInstanceOf(sourceObject, typeInfo.type.ctor))\n        {\n            let expectedName = nameof(typeInfo.type.ctor);\n            let actualName = nameof(sourceObject.constructor);\n\n            this._errorHandler(new TypeError(\n                `Could not serialize '${memberName}': expected '${expectedName}', got '${actualName}'.`),\n            );\n            return;\n        }\n\n        if (isDirectlySerializableNativeType(typeInfo.type.ctor))\n        {\n            return sourceObject;\n        }\n        else if (typeInfo.type.ctor === ArrayBuffer)\n        {\n            return this.convertAsArrayBuffer(sourceObject);\n        }\n        else if (typeInfo.type.ctor === DataView)\n        {\n            return this.convertAsDataView(sourceObject);\n        }\n        else if (typeInfo.type instanceof ArrayTypeDescriptor)\n        {\n            return this.convertAsArray(sourceObject, typeInfo.type, memberName, memberOptions);\n        }\n        else if (typeInfo.type instanceof SetTypeDescriptor)\n        {\n            return this.convertAsSet(sourceObject, typeInfo.type, memberName, memberOptions);\n        }\n        else if (typeInfo.type instanceof MapTypeDescriptor)\n        {\n            return this.convertAsMap(sourceObject, typeInfo.type, memberName, memberOptions);\n        }\n        else if (isTypeTypedArray(typeInfo.type.ctor))\n        {\n            return this.convertAsTypedArray(sourceObject);\n        }\n        else if (typeof sourceObject === \"object\")\n        {\n            return this.convertAsObject(sourceObject, typeInfo, memberName, memberOptions);\n        }\n    }\n\n    /**\n     * Performs the conversion of a typed object (usually a class instance) to a simple\n     * javascript object for serialization.\n     */\n    public convertAsObject(\n        sourceObject: IndexedObject,\n        typeInfo: IScopeTypeInfo,\n        memberName?: string,\n        memberOptions?: OptionsBase,\n    ) {\n        let sourceTypeMetadata: JsonObjectMetadata|undefined;\n        let targetObject: IndexedObject;\n\n        if (sourceObject.constructor !== typeInfo.type.ctor && sourceObject instanceof typeInfo.type.ctor)\n        {\n            // The source object is not of the expected type, but it is a valid subtype.\n            // This is OK, and we'll proceed to gather object metadata from the subtype instead.\n            sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(sourceObject.constructor);\n        }\n        else\n        {\n            sourceTypeMetadata = JsonObjectMetadata.getFromConstructor(typeInfo.type.ctor);\n        }\n\n        if (sourceTypeMetadata)\n        {\n\n            if (sourceTypeMetadata.beforeSerializationMethodName) {\n                // check for member first\n                if (typeof (sourceObject as any)[sourceTypeMetadata.beforeSerializationMethodName] === \"function\")\n                {\n                    (sourceObject as any)[sourceTypeMetadata.beforeSerializationMethodName]();\n                }\n                // check for static\n                else if (typeof (sourceObject.constructor as any)[sourceTypeMetadata.beforeSerializationMethodName] === \"function\")\n                {\n                    (sourceObject.constructor as any)[sourceTypeMetadata.beforeSerializationMethodName]();\n                }\n                else \n                {\n                    this._errorHandler(new TypeError(\n                        `beforeSerialization callback '${nameof(sourceTypeMetadata.classType)}.${sourceTypeMetadata.beforeSerializationMethodName}' is not a method.`\n                    ));\n                }\n            }\n\n            const sourceMeta = sourceTypeMetadata;\n            // Strong-typed serialization available.\n            // We'll serialize by members that have been marked with @jsonMember (including array/set/map members),\n            // and perform recursive conversion on each of them. The converted objects are put on the 'targetObject',\n            // which is what will be put into 'JSON.stringify' finally.\n            targetObject = {};\n\n            const classOptions = mergeOptions(this.options, sourceMeta.options);\n\n            sourceMeta.dataMembers.forEach((objMemberMetadata) =>\n            {\n                const objMemberOptions = mergeOptions(classOptions, objMemberMetadata.options);\n                let serialized;\n                if (objMemberMetadata.serializer) {\n                    serialized = objMemberMetadata.serializer(sourceObject[objMemberMetadata.key]);\n                } else if (objMemberMetadata.type) {\n                    serialized = this.convertSingleValue(\n                        sourceObject[objMemberMetadata.key],\n                        {\n                            type: objMemberMetadata.type,\n                        },\n                        `${nameof(sourceMeta.classType)}.${objMemberMetadata.key}`,\n                        objMemberOptions,\n                    );\n                } else {\n                    throw new TypeError(\n                        `Could not serialize ${objMemberMetadata.name}, there is`\n                        + ` no constructor nor serialization function to use.`,\n                    );\n                }\n\n                if (isValueDefined(serialized)\n                    || (this.retrievePreserveNull(objMemberOptions) && serialized === null)\n                ) {\n                    targetObject[objMemberMetadata.name] = serialized;\n                }\n            });\n        }\n        else\n        {\n            // Untyped serialization, \"as-is\", we'll just pass the object on.\n            // We'll clone the source object, because type hints are added to the object itself, and we don't want to modify to the original object.\n            targetObject = { ...sourceObject };\n        }\n\n        // Add type-hint.\n        this._typeHintEmitter(targetObject, sourceObject, typeInfo.type.ctor, sourceTypeMetadata);\n\n        return targetObject;\n    }\n\n    /**\n     * Performs the conversion of an array of typed objects (or primitive values) to an array of simple javascript objects (or primitive values) for\n     * serialization.\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @param memberOptions If converted as a member, the member options.\n     */\n    public convertAsArray(\n        sourceObject: any[],\n        type: ArrayTypeDescriptor,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): any[] {\n        // Check the type of each element, individually.\n        // If at least one array element type is incorrect, we return undefined, which results in no\n        // value emitted during serialization. This is so that invalid element types don't unexpectedly\n        // alter the ordering of other, valid elements, and that no unexpected undefined values are in\n        // the emitted array.\n        sourceObject.forEach((element, i) =>\n        {\n            if (!(this.retrievePreserveNull(memberOptions) && element === null)\n                && !isInstanceOf(element, type.elementType.ctor)\n            ) {\n                const expectedTypeName = nameof(type.elementType.ctor);\n                const actualTypeName = element && nameof(element.constructor);\n                throw new TypeError(`Could not serialize ${memberName}[${i}]:` +\n                    ` expected '${expectedTypeName}', got '${actualTypeName}'.`);\n            }\n        });\n\n        const typeInfoForElements: IScopeTypeInfo = {\n            type: type.elementType,\n        };\n\n        if (memberName)\n        {\n            // Just for debugging purposes.\n            memberName += \"[]\";\n        }\n\n        return sourceObject.map(\n            element => this.convertSingleValue(\n                element, typeInfoForElements, memberName, memberOptions\n            ),\n        );\n    }\n\n    /**\n     * Performs the conversion of a set of typed objects (or primitive values) into an array\n     * of simple javascript objects.\n     *\n     * @param sourceObject\n     * @param expectedElementType The constructor of the expected Set elements\n     *        (e.g. `Number` for `Set<number>`, or `MyClass` for `Set<MyClass>`).\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @param memberOptions If converted as a member, the member options.\n     * @returns\n     */\n    public convertAsSet(\n        sourceObject: Set<any>,\n        expectedElementType: SetTypeDescriptor,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): any[] {\n        let elementTypeInfo: IScopeTypeInfo = {\n            type: expectedElementType.elementType,\n        };\n\n        // For debugging and error tracking.\n        if (memberName) memberName += \"[]\";\n\n        let resultArray: any[] = [];\n\n        // Convert each element of the set, and put it into an output array.\n        // The output array is the one serialized, as JSON.stringify does not support Set serialization.\n        // (TODO: clarification needed)\n        sourceObject.forEach(element =>\n        {\n            let resultElement = this.convertSingleValue(element, elementTypeInfo, memberName, memberOptions);\n\n            // Add to output if the source element was undefined, OR the converted element is defined.\n            // This will add intentionally undefined values to output, but not values that became undefined\n            // DURING serializing (usually because of a type-error).\n            if (!isValueDefined(element) || isValueDefined(resultElement))\n            {\n                resultArray.push(resultElement);\n            }\n        });\n\n        return resultArray;\n    }\n\n    /**\n     * Performs the conversion of a map of typed objects (or primitive values) into an array\n     * of simple javascript objects with `key` and `value` properties.\n     *\n     * @param sourceObject\n     * @param memberName Name of the object being serialized, used for debugging purposes.\n     * @param memberOptions If converted as a member, the member options.\n     */\n    public convertAsMap(\n        sourceObject: Map<any, any>,\n        type: MapTypeDescriptor,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): Array<{ key: any, value: any }> {\n\n        let elementTypeInfo: IScopeTypeInfo = {\n            type: type.valueType,\n        };\n\n        let keyTypeInfo: IScopeTypeInfo = {\n            type: type.keyType,\n        };\n\n        if (memberName) memberName += \"[]\";\n\n        const resultArray: Array<{ key: any, value: any }> = [];\n        const preserveNull = this.retrievePreserveNull(memberOptions);\n\n        // Convert each *entry* in the map to a simple javascript object with key and value properties.\n        sourceObject.forEach((value, key) =>\n        {\n            let resultKeyValuePairObj = {\n                key: this.convertSingleValue(key, keyTypeInfo, memberName, memberOptions),\n                value: this.convertSingleValue(value, elementTypeInfo, memberName, memberOptions),\n            };\n\n            // We are not going to emit entries with undefined keys OR undefined values.\n            const keyDefined = isValueDefined(resultKeyValuePairObj.key);\n            const valueDefined = isValueDefined(resultKeyValuePairObj.value)\n                || (resultKeyValuePairObj.value === null && preserveNull);\n            if (keyDefined && valueDefined)\n            {\n                resultArray.push(resultKeyValuePairObj);\n            }\n        });\n\n        return resultArray;\n    }\n\n    /**\n     * Performs the conversion of a typed javascript array to a simple untyped javascript array.\n     * This is needed because typed arrays are otherwise serialized as objects, so we'll end up\n     * with something like \"{ 0: 0, 1: 1, ... }\".\n     *\n     * @param sourceObject\n     * @returns\n     */\n    public convertAsTypedArray(sourceObject: ArrayBufferView)\n    {\n        return Array.from(sourceObject as any);\n    }\n\n    /**\n     * Performs the conversion of a raw ArrayBuffer to a string.\n     */\n    public convertAsArrayBuffer(buffer: ArrayBuffer)\n    {\n        // ArrayBuffer -> 16-bit character codes -> character array -> joined string.\n        return Array.from(new Uint16Array(buffer)).map(charCode => String.fromCharCode(charCode)).join(\"\");\n    }\n\n    /**\n     * Performs the conversion of DataView, converting its internal ArrayBuffer to a string and\n     * returning that string.\n     */\n    public convertAsDataView(dataView: DataView)\n    {\n        return this.convertAsArrayBuffer(dataView.buffer);\n    }\n\n    private retrievePreserveNull(memberOptions?: OptionsBase): boolean {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    }\n}\n","import { nameof, logError, isSubtypeOf, isValueDefined, isDirectlyDeserializableNativeType } from \"./helpers\";\nimport { Constructor, IndexedObject } from \"./types\";\nimport { JsonObjectMetadata } from \"./metadata\";\nimport { getOptionValue, mergeOptions, OptionsBase } from \"./options-base\";\nimport {\n    ArrayTypeDescriptor,\n    ConcreteTypeDescriptor,\n    MapTypeDescriptor,\n    SetTypeDescriptor,\n    TypeDescriptor,\n} from \"./type-descriptor\";\n\nexport interface IScopeTypeInfo\n{\n    type: TypeDescriptor,\n    knownTypes: Map<string, Function>;\n}\n\nexport type TypeResolver = (sourceObject: Object, knownTypes: Map<string, Function>) => Function|undefined|null;\n\nfunction defaultTypeResolver(sourceObject: any, knownTypes: Map<string, Function>): Function|undefined {\n    if (sourceObject.__type) return knownTypes.get(sourceObject.__type);\n}\n\n/**\n * Utility class, converts a simple/untyped javascript object-tree to a typed object-tree.\n * It is used after parsing a JSON-string.\n */\nexport class Deserializer<T>\n{\n    public options?: OptionsBase;\n\n    private _typeResolver: TypeResolver = defaultTypeResolver;\n    private _nameResolver?: (ctor: Function) => string;\n    private _errorHandler: (error: Error) => void = logError;\n\n    public setNameResolver(nameResolverCallback: (ctor: Function) => string)\n    {\n        this._nameResolver = nameResolverCallback;\n    }\n\n    public setTypeResolver(typeResolverCallback: TypeResolver)\n    {\n        if (typeof typeResolverCallback !== \"function\")\n        {\n            throw new TypeError(\"'typeResolverCallback' is not a function.\");\n        }\n\n        this._typeResolver = typeResolverCallback;\n    }\n\n    public setErrorHandler(errorHandlerCallback: (error: Error) => void)\n    {\n        if (typeof errorHandlerCallback !== \"function\")\n        {\n            throw new TypeError(\"'errorHandlerCallback' is not a function.\");\n        }\n\n        this._errorHandler = errorHandlerCallback;\n    }\n\n    public convertAsObject(\n        sourceObject: IndexedObject,\n        sourceObjectTypeInfo: IScopeTypeInfo,\n        objectName = \"object\",\n        memberOptions?: OptionsBase,\n    ) {\n        if (typeof sourceObject !== \"object\" || sourceObject === null)\n        {\n            this._errorHandler(new TypeError(`Cannot deserialize ${objectName}: 'sourceObject' must be a defined object.`));\n            return undefined;\n        }\n\n        if (!(sourceObjectTypeInfo.type instanceof ConcreteTypeDescriptor)) {\n            this._errorHandler(new TypeError(`Cannot deserialize ${objectName}: type is an unknown generic type.`));\n            return undefined;\n        }\n\n        let expectedSelfType = sourceObjectTypeInfo.type.ctor;\n        let sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(expectedSelfType);\n        let knownTypeConstructors = sourceObjectTypeInfo.knownTypes;\n\n        if (sourceObjectMetadata)\n        {\n            // Merge known types received from \"above\" with known types defined on the current type.\n            knownTypeConstructors = this._mergeKnownTypes(\n                knownTypeConstructors,\n                this._createKnownTypesMap(sourceObjectMetadata.knownTypes),\n            );\n        }\n\n        // Check if a type-hint is available from the source object.\n        const typeFromTypeHint = this._typeResolver(sourceObject, knownTypeConstructors);\n\n        if (typeFromTypeHint)\n        {\n            // Check if type hint is a valid subtype of the expected source type.\n            if (isSubtypeOf(typeFromTypeHint, expectedSelfType))\n            {\n                // Hell yes.\n                expectedSelfType = typeFromTypeHint;\n                sourceObjectMetadata = JsonObjectMetadata.getFromConstructor(typeFromTypeHint);\n\n                if (sourceObjectMetadata)\n                {\n                    // Also merge new known types from subtype.\n                    knownTypeConstructors = this._mergeKnownTypes(\n                        knownTypeConstructors,\n                        this._createKnownTypesMap(sourceObjectMetadata.knownTypes),\n                    );\n                }\n            }\n        }\n\n        if (sourceObjectMetadata && sourceObjectMetadata.isExplicitlyMarked)\n        {\n            const sourceMetadata = sourceObjectMetadata;\n            // Strong-typed deserialization available, get to it.\n            // First deserialize properties into a temporary object.\n            const sourceObjectWithDeserializedProperties = {} as IndexedObject;\n\n            const classOptions = mergeOptions(this.options, sourceMetadata.options);\n\n            // Deserialize by expected properties.\n            sourceMetadata.dataMembers.forEach((objMemberMetadata, propKey) =>\n            {\n                const objMemberValue = sourceObject[propKey];\n                const objMemberDebugName = `${nameof(sourceMetadata.classType)}.${propKey}`;\n                const objMemberOptions = mergeOptions(classOptions, objMemberMetadata.options);\n\n                let revivedValue;\n                if (objMemberMetadata.deserializer) {\n                    revivedValue = objMemberMetadata.deserializer(objMemberValue);\n                } else if (objMemberMetadata.type) {\n                    revivedValue = this.convertSingleValue(\n                        objMemberValue,\n                        {\n                            type: objMemberMetadata.type,\n                            // elementConstructor: objMemberMetadata.elementType,\n                            // keyConstructor: objMemberMetadata.keyType,\n                            knownTypes: knownTypeConstructors\n                        },\n                        objMemberDebugName,\n                        objMemberOptions,\n                    );\n                } else {\n                    throw new TypeError(\n                        `Cannot deserialize ${objMemberDebugName} there is`\n                        + ` no constructor nor deserialization function to use.`,\n                    );\n                }\n\n                if (isValueDefined(revivedValue)\n                    || (this.retrievePreserveNull(objMemberOptions) && revivedValue === null)\n                ) {\n                    sourceObjectWithDeserializedProperties[objMemberMetadata.key] = revivedValue;\n                }\n                else if (objMemberMetadata.isRequired)\n                {\n                    this._errorHandler(new TypeError(`Missing required member '${objMemberDebugName}'.`));\n                }\n            });\n\n            // Next, instantiate target object.\n            let targetObject: IndexedObject;\n\n            if (typeof sourceObjectMetadata.initializerCallback === \"function\")\n            {\n                try\n                {\n                    targetObject = sourceObjectMetadata.initializerCallback(\n                        sourceObjectWithDeserializedProperties,\n                        sourceObject,\n                    );\n\n                    // Check the validity of user-defined initializer callback.\n                    if (!targetObject)\n                    {\n                        throw new TypeError(\n                            `Cannot deserialize ${objectName}:`\n                            + ` 'initializer' function returned undefined/null`\n                            + `, but '${nameof(sourceObjectMetadata.classType)}' was expected.`,\n                        );\n                    }\n                    else if (!(targetObject instanceof sourceObjectMetadata.classType))\n                    {\n                        throw new TypeError(\n                            `Cannot deserialize ${objectName}:`\n                            + `'initializer' returned '${nameof(targetObject.constructor)}'`\n                            + `, but '${nameof(sourceObjectMetadata.classType)}' was expected`\n                            + `, and '${nameof(targetObject.constructor)}' is not a subtype of`\n                            + ` '${nameof(sourceObjectMetadata.classType)}'`,\n                        );\n                    }\n                }\n                catch (e)\n                {\n                    this._errorHandler(e);\n                    return undefined;\n                }\n            }\n            else\n            {\n                targetObject = this._instantiateType(expectedSelfType);\n            }\n\n            // Finally, assign deserialized properties to target object.\n            Object.assign(targetObject, sourceObjectWithDeserializedProperties);\n\n            // Call onDeserialized method (if any).\n            if (sourceObjectMetadata.onDeserializedMethodName)\n            {\n                // check for member first\n                if (typeof (targetObject as any)[sourceObjectMetadata.onDeserializedMethodName] === \"function\")\n                {\n                    (targetObject as any)[sourceObjectMetadata.onDeserializedMethodName]();\n                }\n                // check for static\n                else if (typeof (targetObject.constructor as any)[sourceObjectMetadata.onDeserializedMethodName] === \"function\")\n                {\n                    (targetObject.constructor as any)[sourceObjectMetadata.onDeserializedMethodName]();\n                }\n                else\n                {\n                    this._errorHandler(new TypeError(\n                        `onDeserialized callback '${nameof(sourceObjectMetadata.classType)}.${sourceObjectMetadata.onDeserializedMethodName}' is not a method.`\n                    ));\n                }\n            }\n\n            return targetObject;\n        }\n        else\n        {\n            // Untyped deserialization into Object instance.\n            let targetObject = {} as IndexedObject;\n\n            Object.keys(sourceObject).forEach(sourceKey =>\n            {\n                targetObject[sourceKey] = this.convertSingleValue(sourceObject[sourceKey], {\n                    type: new ConcreteTypeDescriptor(sourceObject[sourceKey].constructor),\n                    knownTypes: sourceObjectTypeInfo.knownTypes,\n                    // elementConstructor: sourceObjectTypeInfo.elementConstructor,\n                    // keyConstructor: sourceObjectTypeInfo.keyConstructor\n                }, sourceKey);\n            });\n\n            return targetObject;\n        }\n    }\n\n    public convertSingleValue(\n        sourceObject: any,\n        typeInfo: IScopeTypeInfo,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ) {\n        let expectedSelfType = typeInfo.type;\n        const expectedTypeIsConcrete = expectedSelfType instanceof ConcreteTypeDescriptor;\n        let srcTypeNameForDebug = sourceObject ? nameof(sourceObject.constructor) : \"undefined\";\n\n        if (this.retrievePreserveNull(memberOptions) && sourceObject === null)\n        {\n            return null;\n        }\n        else if (!isValueDefined(sourceObject))\n        {\n            return;\n        }\n        else if (expectedTypeIsConcrete && isDirectlyDeserializableNativeType(expectedSelfType.ctor))\n        {\n            if (sourceObject.constructor === expectedSelfType.ctor)\n            {\n                return sourceObject;\n            }\n            else\n            {\n                throw new TypeError(this._makeTypeErrorMessage(nameof(expectedSelfType.ctor), sourceObject.constructor, memberName));\n            }\n        }\n        else if (expectedTypeIsConcrete && expectedSelfType.ctor === Date)\n        {\n            // Support for Date with ISO 8601 format, or with numeric timestamp (milliseconds elapsed since the Epoch).\n            // ISO 8601 spec.: https://www.w3.org/TR/NOTE-datetime\n\n            if (typeof sourceObject === \"string\" || (typeof sourceObject === \"number\" && sourceObject > 0))\n                return new Date(sourceObject as any);\n            else\n                this._throwTypeMismatchError(\"Date\", \"an ISO-8601 string\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedTypeIsConcrete && (expectedSelfType.ctor === Float32Array || expectedSelfType.ctor === Float64Array))\n        {\n            // Deserialize Float Array from number[].\n            return this._convertAsFloatArray(\n                sourceObject,\n                expectedSelfType as any,\n                srcTypeNameForDebug,\n                memberName,\n            );\n        }\n        else if (\n            expectedTypeIsConcrete && (\n                expectedSelfType.ctor === Uint8Array\n                || expectedSelfType.ctor === Uint8ClampedArray\n                || expectedSelfType.ctor === Uint16Array\n                || expectedSelfType.ctor === Uint32Array\n            )\n        ) {\n            // Deserialize Uint array from number[].\n            return this._convertAsUintArray(\n                sourceObject,\n                expectedSelfType.ctor as any,\n                srcTypeNameForDebug,\n                memberName,\n            );\n        }\n        else if (expectedTypeIsConcrete && expectedSelfType.ctor === ArrayBuffer)\n        {\n            if (typeof sourceObject === \"string\")\n                return this._stringToArrayBuffer(sourceObject);\n            else\n                this._throwTypeMismatchError(\"ArrayBuffer\", \"a string source\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedTypeIsConcrete && expectedSelfType.ctor === DataView)\n        {\n            if (typeof sourceObject === \"string\")\n                return this._stringToDataView(sourceObject);\n            else\n                this._throwTypeMismatchError(\"DataView\", \"a string source\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType instanceof ArrayTypeDescriptor)\n        {\n            if (Array.isArray(sourceObject))\n                return this.convertAsArray(sourceObject, typeInfo, memberName, memberOptions);\n            else\n                throw new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName));\n        }\n        else if (expectedSelfType instanceof SetTypeDescriptor)\n        {\n            if (Array.isArray(sourceObject))\n                return this.convertAsSet(sourceObject, typeInfo, memberName, memberOptions);\n            else\n                this._throwTypeMismatchError(\"Set\", \"Array\", srcTypeNameForDebug, memberName);\n        }\n        else if (expectedSelfType instanceof MapTypeDescriptor)\n        {\n            if (Array.isArray(sourceObject))\n                return this.convertAsMap(sourceObject, typeInfo, memberName, memberOptions);\n            else\n                this._throwTypeMismatchError(\"Map\", \"a source array of key-value-pair objects\", srcTypeNameForDebug, memberName);\n        }\n        else if (sourceObject && typeof sourceObject === \"object\")\n        {\n            return this.convertAsObject(sourceObject, typeInfo, memberName, memberOptions);\n        }\n    }\n\n    public convertAsArray(\n        sourceObject: any,\n        typeInfo: IScopeTypeInfo,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): any[] {\n        if (!(Array.isArray(sourceObject)))\n        {\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n            return [];\n        }\n\n        // if (!typeInfo.elementConstructor || !typeInfo.elementConstructor.length)\n        // {\n        //     this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Array: missing constructor reference of Array elements.`));\n        //     return [];\n        // }\n\n        let elementTypeInfo: IScopeTypeInfo = {\n            type: (typeInfo.type as ArrayTypeDescriptor).elementType,\n            // selfConstructor: typeInfo.elementConstructor[0],\n            // elementConstructor: (typeInfo.elementConstructor.length > 1) ? typeInfo.elementConstructor.slice(1) : [],\n            knownTypes: typeInfo.knownTypes\n        };\n\n        return sourceObject.map(element =>\n        {\n            // If an array element fails to deserialize, substitute with undefined. This is so that the original ordering is not interrupted by faulty\n            // entries, as an Array is ordered.\n            try\n            {\n                return this.convertSingleValue(element, elementTypeInfo, `${memberName}[]`, memberOptions);\n            }\n            catch (e)\n            {\n                this._errorHandler(e);\n\n                // Keep filling the array here with undefined to keep original ordering.\n                // Note: this is just aesthetics, not returning anything produces the same result.\n                return undefined;\n            }\n        });\n    }\n\n    public convertAsSet(\n        sourceObject: any,\n        typeInfo: IScopeTypeInfo,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): Set<any> {\n        if (!(Array.isArray(sourceObject)))\n        {\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n            return new Set<any>();\n        }\n\n        // if (!typeInfo.elementConstructor || !typeInfo.elementConstructor.length)\n        // {\n        //     this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Set: missing constructor reference of Set elements.`));\n        //     return new Set<any>();\n        // }\n\n        let elementTypeInfo: IScopeTypeInfo = {\n            // selfConstructor: typeInfo.elementConstructor[0],\n            // elementConstructor: (typeInfo.elementConstructor.length > 1) ? typeInfo.elementConstructor.slice(1) : [],\n            type: (typeInfo.type as SetTypeDescriptor).elementType,\n            knownTypes: typeInfo.knownTypes\n        };\n        let resultSet = new Set<any>();\n\n        sourceObject.forEach((element, i) =>\n        {\n            try\n            {\n                resultSet.add(this.convertSingleValue(\n                    element,\n                    elementTypeInfo,\n                    `${memberName}[${i}]`,\n                    memberOptions,\n                ));\n            }\n            catch (e)\n            {\n                // Faulty entries are skipped, because a Set is not ordered, and skipping an entry\n                // does not affect others.\n                this._errorHandler(e);\n            }\n        });\n\n        return resultSet;\n    }\n\n    public convertAsMap(\n        sourceObject: any,\n        typeInfo: IScopeTypeInfo,\n        memberName = \"object\",\n        memberOptions?: OptionsBase,\n    ): Map<any, any> {\n        if (!(Array.isArray(sourceObject)))\n            this._errorHandler(new TypeError(this._makeTypeErrorMessage(Array, sourceObject.constructor, memberName)));\n\n        // if (!typeInfo.keyConstructor)\n        // {\n        //     this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Map: missing key constructor.`));\n        //     return new Map<any, any>();\n        // }\n        //\n        // if (!typeInfo.elementConstructor || !typeInfo.elementConstructor.length)\n        // {\n        //     this._errorHandler(new TypeError(`Could not deserialize ${memberName} as Map: missing value constructor.`));\n        //     return new Map<any, any>();\n        // }\n\n        let keyTypeInfo: IScopeTypeInfo = {\n            type: (typeInfo.type as MapTypeDescriptor).keyType,\n            knownTypes: typeInfo.knownTypes\n        };\n\n        let valueTypeInfo: IScopeTypeInfo = {\n            type: (typeInfo.type as MapTypeDescriptor).valueType,\n            // selfConstructor: typeInfo.elementConstructor[0],\n            // elementConstructor: (typeInfo.elementConstructor.length > 1) ? typeInfo.elementConstructor.slice(1) : [],\n            knownTypes: typeInfo.knownTypes\n        };\n\n        let resultMap = new Map<any, any>();\n\n        sourceObject.forEach((element: any) =>\n        {\n            try\n            {\n                let key = this.convertSingleValue(element.key, keyTypeInfo, memberName, memberOptions);\n\n                // Undefined/null keys not supported, skip if so.\n                if (isValueDefined(key))\n                {\n                    resultMap.set(\n                        key,\n                        this.convertSingleValue(\n                            element.value,\n                            valueTypeInfo,\n                            `${memberName}[${key}]`,\n                            memberOptions,\n                        ),\n                    );\n                }\n            }\n            catch (e)\n            {\n                // Faulty entries are skipped, because a Map is not ordered,\n                // and skipping an entry does not affect others.\n                this._errorHandler(e);\n            }\n        });\n\n        return resultMap;\n    }\n\n    private _convertAsFloatArray<T extends Float32Array | Float64Array>(\n        sourceObject: any,\n        arrayType: Constructor<T>,\n        srcTypeNameForDebug: string,\n        memberName: string,\n    ): T {\n        if (Array.isArray(sourceObject) && sourceObject.every(elem => !isNaN(elem)))\n            return new arrayType(sourceObject);\n        return this._throwTypeMismatchError(\n            arrayType.name,\n            \"a numeric source array\",\n            srcTypeNameForDebug,\n            memberName,\n        );\n    }\n\n    private _convertAsUintArray<T extends Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array>(\n        sourceObject: any,\n        arrayType: Constructor<T>,\n        srcTypeNameForDebug: string,\n        memberName: string,\n    ): T {\n        if (Array.isArray(sourceObject) && sourceObject.every(elem => !isNaN(elem)))\n            return new arrayType(sourceObject.map(value => ~~value));\n        return this._throwTypeMismatchError(\n            arrayType.name,\n            \"a numeric source array\",\n            srcTypeNameForDebug,\n            memberName,\n        );\n    }\n\n    private _throwTypeMismatchError(\n        targetType: string,\n        expectedSourceType: string,\n        actualSourceType: string,\n        memberName: string,\n    ): never {\n        throw new TypeError(\n            `Could not deserialize ${memberName} as ${targetType}:`\n            + ` expected ${expectedSourceType}, got ${actualSourceType}.`,\n        );\n    }\n\n    private _makeTypeErrorMessage(expectedType: Function | string, actualType: Function | string, memberName: string)\n    {\n        const expectedTypeName = (typeof expectedType === \"function\") ? nameof(expectedType) : expectedType;\n        const actualTypeName = (typeof actualType === \"function\") ? nameof(actualType) : actualType;\n\n        return `Could not deserialize ${memberName}: expected '${expectedTypeName}', got '${actualTypeName}'.`;\n    }\n\n    private _instantiateType(ctor: any)\n    {\n        return new ctor();\n    }\n\n    private _mergeKnownTypes(...knownTypeMaps: Array<Map<string, Function>>)\n    {\n        let result = new Map<string, Function>();\n\n        knownTypeMaps.forEach(knownTypes =>\n        {\n            knownTypes.forEach((ctor, name) =>\n            {\n                if (this._nameResolver)\n                {\n                    result.set(this._nameResolver(ctor), ctor);\n                }\n                else\n                {\n                    result.set(name, ctor);\n                }\n            });\n        });\n\n        return result;\n    }\n\n    private _createKnownTypesMap(knowTypes: Set<Function>)\n    {\n        const map = new Map<string, Function>();\n\n        knowTypes.forEach(ctor =>\n        {\n            if (this._nameResolver)\n            {\n                map.set(this._nameResolver(ctor), ctor);\n            }\n            else\n            {\n                const knownTypeMeta = JsonObjectMetadata.getFromConstructor(ctor);\n                const name = knownTypeMeta && knownTypeMeta.isExplicitlyMarked && knownTypeMeta.name\n                    ? knownTypeMeta.name\n                    : ctor.name;\n                map.set(name, ctor);\n            }\n        });\n\n        return map;\n    }\n\n    private _stringToArrayBuffer(str: string)\n    {\n        let buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n        let bufView = new Uint16Array(buf);\n\n        for (let i = 0, strLen = str.length; i < strLen; i++)\n        {\n            bufView[i] = str.charCodeAt(i);\n        }\n\n        return buf;\n    }\n\n    private _stringToDataView(str: string)\n    {\n        return new DataView(this._stringToArrayBuffer(str));\n    }\n\n    private retrievePreserveNull(memberOptions?: OptionsBase): boolean {\n        return getOptionValue('preserveNull', mergeOptions(this.options, memberOptions));\n    }\n}\n","import { nameof, logError, isReflectMetadataSupported, MISSING_REFLECT_CONF_MSG } from \"./helpers\";\nimport { injectMetadataInformation } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\nimport {\n    ArrayTypeDescriptor,\n    ensureTypeDescriptor,\n    isTypelike,\n    TypeDescriptor,\n} from \"./type-descriptor\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonArrayMemberOptions extends OptionsBase\n{\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, an empty array is emitted if the property is undefined/uninitialized. */\n    emitDefaultValue?: boolean;\n\n    /** Sets array dimensions (e.g. 1 for 'number[]' or 2 for 'number[][]'). Defaults to 1. */\n    dimensions?: number;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that a property, of type array, is part of an object when serializing.\n * @param elementConstructor Constructor of array elements (e.g. 'Number' for 'number[]', or 'Date' for 'Date[]').\n * @param options Additional options.\n */\nexport function jsonArrayMember(elementConstructor: Function|TypeDescriptor, options: IJsonArrayMemberOptions = {})\n{\n    return (target: Object, propKey: string | symbol) =>\n    {\n        const decoratorName = `@jsonArrayMember on ${nameof(target.constructor)}.${String(propKey)}`; // For error messages.\n\n        if (!isTypelike(elementConstructor))\n        {\n            logError(`${decoratorName}: could not resolve constructor of array elements at runtime.`);\n            return;\n        }\n\n        const dimensions = options.dimensions === undefined ? 1 : options.dimensions;\n        if (!isNaN(dimensions) && dimensions < 1)\n        {\n            logError(`${decoratorName}: 'dimensions' option must be at least 1.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonArrayMember' has been used on an array.\n        if (isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Array)\n        {\n            logError(`${decoratorName}: property is not an Array. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: createArrayType(ensureTypeDescriptor(elementConstructor), dimensions),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n\nexport function createArrayType(elementType: TypeDescriptor, dimensions: number): ArrayTypeDescriptor {\n    let type = new ArrayTypeDescriptor(elementType);\n    for (let i = 1; i < dimensions; ++i) {\n        type = new ArrayTypeDescriptor(type);\n    }\n    return type;\n}\n","import { Constructor } from \"./typedjson/types\";\nimport { Serializer, TypeHintEmitter } from \"./typedjson/serializer\";\nimport { Deserializer, TypeResolver } from \"./typedjson/deserializer\";\nimport { JsonObjectMetadata } from \"./typedjson/metadata\";\nimport { logError, logWarning, nameof, parseToJSObject } from \"./typedjson/helpers\";\nimport { extractOptionBase, OptionsBase } from \"./typedjson/options-base\";\nimport { createArrayType } from \"./typedjson/json-array-member\";\nimport { ensureTypeDescriptor, MapT, SetT } from './typedjson/type-descriptor';\n\nexport type JsonTypes = Object|boolean|string|number|null|undefined;\nexport { TypeResolver, TypeHintEmitter };\n\nexport interface ITypedJSONSettings extends OptionsBase\n{\n    /**\n     * Sets the handler callback to invoke on errors during serializing and deserializing.\n     * Re-throwing errors in this function will halt serialization/deserialization.\n     * The default behavior is to log errors to the console.\n     */\n    errorHandler?: (e: Error) => void;\n\n    /**\n     * Sets a callback that determines the constructor of the correct sub-type of polymorphic\n     * objects while deserializing.\n     * The default behavior is to read the type-name from the '__type' property of 'sourceObject',\n     * and look it up in 'knownTypes'.\n     * The constructor of the sub-type should be returned.\n     */\n    typeResolver?: TypeResolver;\n\n    nameResolver?: (ctor: Function) => string;\n\n    /**\n     * Sets a callback that writes type-hints to serialized objects.\n     * The default behavior is to write the type-name to the '__type' property, if a derived type\n     * is present in place of a base type.\n     */\n    typeHintEmitter?: TypeHintEmitter;\n\n    /**\n     * Sets the amount of indentation to use in produced JSON strings.\n     * Default value is 0, or no indentation.\n     */\n    indent?: number;\n\n    replacer?: (key: string, value: any) => any;\n\n    knownTypes?: Array<Constructor<any>>;\n}\n\nexport class TypedJSON<T>\n{\n    //#region Static\n    public static parse<T>(\n        object: any, rootType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): T|undefined {\n        return new TypedJSON(rootType, settings).parse(object);\n    }\n\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings?: ITypedJSONSettings,\n        dimensions?: 1\n    ): T[];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings: ITypedJSONSettings|undefined,\n        dimensions: 2\n    ): T[][];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings: ITypedJSONSettings|undefined,\n        dimensions: 3\n    ): T[][][];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings: ITypedJSONSettings|undefined,\n        dimensions: 4\n    ): T[][][][];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings: ITypedJSONSettings|undefined,\n        dimensions: 5\n    ): T[][][][][];\n    public static parseAsArray<T>(\n        object: any,\n        elementType: Constructor<T>,\n        settings?: ITypedJSONSettings,\n        dimensions?: number\n    ): any[] {\n        return new TypedJSON(elementType, settings).parseAsArray(object, dimensions as any);\n    }\n\n    public static parseAsSet<T>(\n        object: any, elementType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): Set<T> {\n        return new TypedJSON(elementType, settings).parseAsSet(object);\n    }\n\n    public static parseAsMap<K, V>(\n        object: any,\n        keyType: Constructor<K>,\n        valueType: Constructor<V>,\n        settings?: ITypedJSONSettings,\n    ): Map<K, V> {\n        return new TypedJSON(valueType, settings).parseAsMap(object, keyType);\n    }\n\n    public static toPlainJson<T>(\n        object: T, rootType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): JsonTypes {\n        return new TypedJSON(rootType, settings).toPlainJson(object);\n    }\n\n    public static toPlainArray<T>(\n        object: T[], elementType: Constructor<T>, dimensions?: 1, settings?: ITypedJSONSettings,\n    ): Object[];\n    public static toPlainArray<T>(\n        object: T[][], elementType: Constructor<T>, dimensions: 2, settings?: ITypedJSONSettings,\n    ): Object[][];\n    public static toPlainArray<T>(\n        object: T[][][], elementType: Constructor<T>, dimensions: 3, settings?: ITypedJSONSettings,\n    ): Object[][][];\n    public static toPlainArray<T>(\n        object: T[][][][], elementType: Constructor<T>, dimensions: 4, settings?: ITypedJSONSettings,\n    ): Object[][][][];\n    public static toPlainArray<T>(\n        object: T[][][][][], elementType: Constructor<T>, dimensions: 5, settings?: ITypedJSONSettings,\n    ): Object[][][][][];\n    public static toPlainArray<T>(\n        object: any[], elementType: Constructor<T>, dimensions: number, settings?: ITypedJSONSettings,\n    ): any[];\n    public static toPlainArray<T>(\n        object: any[], elementType: Constructor<T>, dimensions?: any, settings?: ITypedJSONSettings,\n    ): any[] {\n        return new TypedJSON(elementType, settings).toPlainArray(object, dimensions);\n    }\n\n    public static toPlainSet<T>(\n        object: Set<T>, elementType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): Object[]|undefined {\n        return new TypedJSON(elementType, settings).toPlainSet(object);\n    }\n\n    public static toPlainMap<K, V>(\n        object: Map<K, V>,\n        keyCtor: Constructor<K>,\n        valueCtor: Constructor<V>,\n        settings?: ITypedJSONSettings,\n    ): { key: any, value: any }[]|undefined {\n        return new TypedJSON(valueCtor, settings).toPlainMap(object, keyCtor);\n    }\n\n    public static stringify<T>(\n        object: T, rootType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(rootType, settings).stringify(object);\n    }\n\n    public static stringifyAsArray<T>(\n        object: T[], elementType: Constructor<T>, dimensions?: 1, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: T[][], elementType: Constructor<T>, dimensions: 2, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: T[][][], elementType: Constructor<T>, dimensions: 3, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: T[][][][], elementType: Constructor<T>, dimensions: 4, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: T[][][][][], elementType: Constructor<T>, dimensions: 5, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: any[], elementType: Constructor<T>, dimensions: number, settings?: ITypedJSONSettings,\n    ): string;\n    public static stringifyAsArray<T>(\n        object: any[], elementType: Constructor<T>, dimensions?: any, settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(elementType, settings).stringifyAsArray(object, dimensions);\n    }\n\n    public static stringifyAsSet<T>(\n        object: Set<T>, elementType: Constructor<T>, settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(elementType, settings).stringifyAsSet(object);\n    }\n\n    public static stringifyAsMap<K, V>(\n        object: Map<K, V>,\n        keyCtor: Constructor<K>,\n        valueCtor: Constructor<V>,\n        settings?: ITypedJSONSettings,\n    ): string {\n        return new TypedJSON(valueCtor, settings).stringifyAsMap(object, keyCtor);\n    }\n\n    private static _globalConfig: ITypedJSONSettings;\n\n    public static setGlobalConfig(config: ITypedJSONSettings)\n    {\n        if (this._globalConfig)\n        {\n            Object.assign(this._globalConfig, config);\n        }\n        else\n        {\n            this._globalConfig = config;\n        }\n    }\n\n    //#endregion\n\n    private serializer: Serializer = new Serializer();\n    private deserializer: Deserializer<T> = new Deserializer<T>();\n    private globalKnownTypes: Array<Constructor<any>> = [];\n    private indent: number = 0;\n    private rootConstructor: Constructor<T>;\n    private errorHandler: (e: Error) => void;\n    private nameResolver: (ctor: Function) => string;\n    private replacer?: (key: string, value: any) => any;\n\n    /**\n     * Creates a new TypedJSON instance to serialize (stringify) and deserialize (parse) object\n     *     instances of the specified root class type.\n     * @param rootType The constructor of the root class type.\n     * @param settings Additional configuration settings.\n     */\n    constructor(rootConstructor: Constructor<T>, settings?: ITypedJSONSettings)\n    {\n        let rootMetadata = JsonObjectMetadata.getFromConstructor(rootConstructor);\n\n        if (!rootMetadata || (!rootMetadata.isExplicitlyMarked && !rootMetadata.isHandledWithoutAnnotation))\n        {\n            throw new TypeError(\"The TypedJSON root data type must have the @jsonObject decorator used.\");\n        }\n\n        this.nameResolver = (ctor) => nameof(ctor);\n        this.rootConstructor = rootConstructor;\n        this.errorHandler = (error) => logError(error);\n\n        if (settings)\n        {\n            this.config(settings);\n        }\n        else if (TypedJSON._globalConfig)\n        {\n            this.config({});\n        }\n    }\n\n    /**\n     * Configures TypedJSON through a settings object.\n     * @param settings The configuration settings object.\n     */\n    public config(settings: ITypedJSONSettings)\n    {\n        if (TypedJSON._globalConfig)\n        {\n            settings = {\n                ...TypedJSON._globalConfig,\n                ...settings\n            };\n\n            if (settings.knownTypes && TypedJSON._globalConfig.knownTypes)\n            {\n                // Merge known-types (also de-duplicate them, so Array -> Set -> Array).\n                settings.knownTypes = Array.from(new Set(\n                    settings.knownTypes.concat(TypedJSON._globalConfig.knownTypes),\n                ));\n            }\n        }\n\n        const options = extractOptionBase(settings);\n        this.serializer.options = options;\n        this.deserializer.options = options;\n\n        if (settings.errorHandler)\n        {\n            this.errorHandler = settings.errorHandler;\n            this.deserializer.setErrorHandler(settings.errorHandler);\n            this.serializer.setErrorHandler(settings.errorHandler);\n        }\n\n        if (settings.replacer) this.replacer = settings.replacer;\n        if (settings.typeResolver) this.deserializer.setTypeResolver(settings.typeResolver);\n        if (settings.typeHintEmitter) this.serializer.setTypeHintEmitter(settings.typeHintEmitter);\n        if (settings.indent) this.indent = settings.indent;\n\n        if (settings.nameResolver)\n        {\n            this.nameResolver = settings.nameResolver;\n            this.deserializer.setNameResolver(settings.nameResolver);\n            // this.serializer.set\n        }\n\n        if (settings.knownTypes)\n        {\n            // Type-check knownTypes elements to recognize errors in advance.\n            settings.knownTypes.forEach((knownType, i) =>\n            {\n                // tslint:disable-next-line:no-null-keyword\n                if (typeof knownType === \"undefined\" || knownType === null)\n                {\n                    logWarning(\n                        `TypedJSON.config: 'knownTypes' contains an undefined/null value (element ${i}).`);\n                }\n            });\n\n            this.globalKnownTypes = settings.knownTypes;\n        }\n    }\n\n    /**\n     * Converts a JSON string to the root class type.\n     * @param object The JSON to parse and convert.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns Deserialized T or undefined if there were errors.\n     */\n    public parse(object: any): T|undefined\n    {\n        const json = parseToJSObject(object, this.rootConstructor);\n\n        let rootMetadata = JsonObjectMetadata.getFromConstructor(this.rootConstructor);\n        let result: T|undefined;\n        let knownTypes = new Map<string, Function>();\n\n        this.globalKnownTypes.filter(ktc => ktc).forEach(knownTypeCtor =>\n        {\n            knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n        });\n\n        if (rootMetadata)\n        {\n            rootMetadata.knownTypes.forEach(knownTypeCtor =>\n            {\n                knownTypes.set(this.nameResolver(knownTypeCtor), knownTypeCtor);\n            });\n        }\n\n        try\n        {\n            result = this.deserializer.convertSingleValue(json, {\n                type: ensureTypeDescriptor(this.rootConstructor),\n                knownTypes: knownTypes,\n            }) as T;\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n\n        return result;\n    }\n\n    public parseAsArray(object: any, dimensions?: 1): T[];\n    public parseAsArray(object: any, dimensions: 2): T[][];\n    public parseAsArray(object: any, dimensions: 3): T[][][];\n    public parseAsArray(object: any, dimensions: 4): T[][][][];\n    public parseAsArray(object: any, dimensions: 5): T[][][][][];\n    public parseAsArray(object: any, dimensions: number): any[];\n    public parseAsArray(object: any, dimensions: number = 1): any[]\n    {\n        const json = parseToJSObject(object, Array);\n        if (json instanceof Array)\n        {\n            return this.deserializer.convertAsArray(json, {\n                type: createArrayType(ensureTypeDescriptor(this.rootConstructor), dimensions),\n                knownTypes: this._mapKnownTypes(this.globalKnownTypes),\n            });\n        }\n        else\n        {\n            this.errorHandler(new TypeError(`Expected 'json' to define an Array`\n                + `, but got ${typeof json}.`));\n        }\n\n        return [];\n    }\n\n    public parseAsSet(object: any): Set<T>\n    {\n        const json = parseToJSObject(object, Set);\n        // A Set<T> is serialized as T[].\n        if (json instanceof Array)\n        {\n            return this.deserializer.convertAsSet(json, {\n                type: SetT(this.rootConstructor),\n                knownTypes: this._mapKnownTypes(this.globalKnownTypes)\n            });\n        }\n        else\n        {\n            this.errorHandler(new TypeError(`Expected 'json' to define a Set (using an Array)`\n                + `, but got ${typeof json}.`,\n            ));\n        }\n\n        return new Set<T>();\n    }\n\n    public parseAsMap<K>(object: any, keyConstructor: Constructor<K>): Map<K, T>\n    {\n        const json = parseToJSObject(object, Map);\n        // A Set<T> is serialized as T[].\n        if (json instanceof Array)\n        {\n            return this.deserializer.convertAsMap(json, {\n                type: MapT(keyConstructor, this.rootConstructor),\n                knownTypes: this._mapKnownTypes(this.globalKnownTypes),\n            });\n        }\n        else\n        {\n            this.errorHandler(new TypeError(`Expected 'json' to define a Set (using an Array)`\n                + `, but got ${typeof json}.`,\n            ));\n        }\n\n        return new Map<K, T>();\n    }\n\n    /**\n     * Converts an instance of the specified class type to a plain JSON object.\n     * @param object The instance to convert to a JSON string.\n     * @returns Serialized object or undefined if an error has occured.\n     */\n    public toPlainJson(object: T): JsonTypes\n    {\n        try\n        {\n            return this.serializer.convertSingleValue(\n                object,\n        {type: ensureTypeDescriptor(this.rootConstructor)},\n            );\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n    }\n\n    public toPlainArray(object: T[], dimensions?: 1): Object[];\n    public toPlainArray(object: T[][], dimensions: 2): Object[][];\n    public toPlainArray(object: T[][][], dimensions: 3): Object[][][];\n    public toPlainArray(object: T[][][][], dimensions: 4): Object[][][][];\n    public toPlainArray(object: T[][][][][], dimensions: 5): Object[][][][][];\n    public toPlainArray(object: any[], dimensions: 1|2|3|4|5 = 1): Object[]|undefined\n    {\n        try\n        {\n            return this.serializer.convertAsArray(\n                object, createArrayType(ensureTypeDescriptor(this.rootConstructor), dimensions));\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n    }\n\n    public toPlainSet(object: Set<T>): Object[]|undefined\n    {\n        try\n        {\n            return this.serializer.convertAsSet(object, SetT(this.rootConstructor));\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n    }\n\n    public toPlainMap<K>(object: Map<K, T>, keyConstructor: Constructor<K>): { key: any, value: any }[]|undefined\n    {\n        try\n        {\n            return this.serializer.convertAsMap(object, MapT(keyConstructor, this.rootConstructor));\n        }\n        catch (e)\n        {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Converts an instance of the specified class type to a JSON string.\n     * @param object The instance to convert to a JSON string.\n     * @throws Error if any errors are thrown in the specified errorHandler callback (re-thrown).\n     * @returns String with the serialized object or an empty string if an error has occured, but\n     *     the errorHandler did not throw.\n     */\n    public stringify(object: T): string\n    {\n        const result = this.toPlainJson(object);\n        if (result === undefined) {\n            return '';\n        }\n        return JSON.stringify(result, this.replacer, this.indent);\n    }\n\n    public stringifyAsArray(object: T[], dimensions?: 1): string;\n    public stringifyAsArray(object: T[][], dimensions: 2): string;\n    public stringifyAsArray(object: T[][][], dimensions: 3): string;\n    public stringifyAsArray(object: T[][][][], dimensions: 4): string;\n    public stringifyAsArray(object: T[][][][][], dimensions: 5): string;\n    public stringifyAsArray(object: any[], dimensions: any): string\n    {\n        return JSON.stringify(this.toPlainArray(object, dimensions), this.replacer, this.indent);\n    }\n\n    public stringifyAsSet(object: Set<T>): string\n    {\n        return JSON.stringify(this.toPlainSet(object), this.replacer, this.indent);\n    }\n\n    public stringifyAsMap<K>(object: Map<K, T>, keyConstructor: Constructor<K>): string\n    {\n        return JSON.stringify(this.toPlainMap(object, keyConstructor), this.replacer, this.indent);\n    }\n\n    private _mapKnownTypes(constructors: Array<Constructor<any>>)\n    {\n        let map = new Map<string, Constructor<any>>();\n\n        constructors.filter(ctor => ctor).forEach(ctor => map.set(this.nameResolver(ctor), ctor));\n\n        return map;\n    }\n}\n","import { Constructor, ParameterlessConstructor } from \"./types\";\nimport { METADATA_FIELD_KEY } from \"./helpers\";\nimport { JsonObjectMetadata } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\n\nexport type InitializerCallback<T> = (sourceObject: T, rawSourceObject: T) => T;\n\nexport interface IJsonObjectOptionsBase extends OptionsBase\n{\n    /**\n     * An array of known types to recognize when encountering type-hints,\n     * or the name of a static method used for determining known types.\n     */\n    knownTypes?: Function[] | string;\n\n    /**\n     * The name of a static or instance method to call when deserialization\n     * of the object is completed.\n     */\n    onDeserialized?: string;\n\n    /**\n     * The name of a static or instance method to call before the serialization\n     * of the typed object is started.\n     */\n    beforeSerialization?: string;\n\n    /**\n     * The name used to differentiate between different polymorphic types.\n     */\n    name?: string;\n}\n\nexport interface IJsonObjectOptionsWithInitializer<T> extends IJsonObjectOptionsBase\n{\n    /**\n     * Function to call before deserializing and initializing the object, accepting two arguments:\n     *   (1) sourceObject, an 'Object' instance with all properties already deserialized, and\n     *   (2) rawSourceObject, a raw 'Object' instance representation of the current object in\n     *       the serialized JSON (i.e. without deserialized properties).\n     */\n    initializer: InitializerCallback<T>;\n}\n\nexport interface IJsonObjectOptions<T> extends IJsonObjectOptionsBase\n{\n    /**\n     * Function to call before deserializing and initializing the object, accepting two arguments:\n     *   (1) sourceObject, an 'Object' instance with all properties already deserialized, and\n     *   (2) rawSourceObject, a raw 'Object' instance representation of the current object in\n     *       the serialized JSON (i.e. without deserialized properties).\n     */\n    initializer?: InitializerCallback<T>;\n}\n\n/**\n * Marks that a class with a parameterized constructor is serializable using TypedJSON, with additional\n * settings. The 'initializer' setting must be specified.\n * @param options Configuration settings.\n */\nexport function jsonObject<T>(options?: IJsonObjectOptionsWithInitializer<T>): (target: Constructor<T>) => void;\n\n/**\n * Marks that a class is serializable using TypedJSON, with additional settings.\n * @param options Configuration settings.\n */\nexport function jsonObject<T>(options?: IJsonObjectOptions<T>): (target: ParameterlessConstructor<T>) => void;\n\n/**\n * Marks that a class with a parameterless constructor is serializable using TypedJSON.\n */\nexport function jsonObject<T>(target: ParameterlessConstructor<T>): void;\n\nexport function jsonObject<T extends Object>(optionsOrTarget?: IJsonObjectOptions<T> | Constructor<T>\n): ((target: Constructor<T>) => void) | void {\n    let options: IJsonObjectOptions<T>;\n\n    if (typeof optionsOrTarget === \"function\")\n    {\n        // jsonObject is being used as a decorator, directly.\n        options = {};\n    }\n    else\n    {\n        // jsonObject is being used as a decorator factory.\n        options = optionsOrTarget || {};\n    }\n\n    function decorator(\n        target: Function\n    ): void {\n        let objectMetadata: JsonObjectMetadata;\n\n        // Create or obtain JsonObjectMetadata object.\n        if (!target.prototype.hasOwnProperty(METADATA_FIELD_KEY))\n        {\n            // Target has no JsonObjectMetadata associated with it yet, create it now.\n            objectMetadata = new JsonObjectMetadata(target);\n\n            // Inherit json members and known types from parent @jsonObject (if any).\n            const parentMetadata: JsonObjectMetadata = target.prototype[METADATA_FIELD_KEY];\n            if (parentMetadata)\n            {\n                parentMetadata.dataMembers\n                    .forEach((memberMetadata, propKey) =>\n                        objectMetadata.dataMembers.set(propKey, memberMetadata));\n                parentMetadata.knownTypes\n                    .forEach((knownType) => objectMetadata.knownTypes.add(knownType));\n            }\n\n            Object.defineProperty(target.prototype, METADATA_FIELD_KEY, {\n                enumerable: false,\n                configurable: false,\n                writable: false,\n                value: objectMetadata\n            });\n        }\n        else\n        {\n            // Target already has JsonObjectMetadata associated with it.\n            objectMetadata = target.prototype[METADATA_FIELD_KEY];\n            objectMetadata.classType = target;\n        }\n\n        // Fill JsonObjectMetadata.\n        objectMetadata.isExplicitlyMarked = true;\n        objectMetadata.onDeserializedMethodName = options.onDeserialized;\n        objectMetadata.beforeSerializationMethodName = options.beforeSerialization;\n        \n        // T extend Object so it is fine\n        objectMetadata.initializerCallback = options.initializer as any;\n        if (options.name)\n        {\n            objectMetadata.name = options.name;\n        }\n        const optionsBase = extractOptionBase(options);\n        if (optionsBase)\n        {\n            objectMetadata.options = optionsBase;\n        }\n\n        // Obtain known-types.\n        if (typeof options.knownTypes === \"string\")\n        {\n            objectMetadata.knownTypeMethodName = options.knownTypes;\n        }\n        else if (options.knownTypes instanceof Array)\n        {\n            options.knownTypes\n                .filter(knownType => !!knownType)\n                .forEach(knownType => objectMetadata.knownTypes.add(knownType));\n        }\n    }\n\n    if (typeof optionsOrTarget === \"function\")\n    {\n        // jsonObject is being used as a decorator, directly.\n        decorator(optionsOrTarget);\n    }\n    else\n    {\n        // jsonObject is being used as a decorator factory.\n        return decorator;\n    }\n}\n","import {\n    nameof, logError, isReflectMetadataSupported, isValueDefined, logWarning, isSubtypeOf, MISSING_REFLECT_CONF_MSG,\n} from \"./helpers\";\nimport { injectMetadataInformation } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\nimport {\n    ConcreteTypeDescriptor,\n    ensureTypeDescriptor,\n    TypeDescriptor,\n} from \"./type-descriptor\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMemberOptions extends OptionsBase\n{\n    /**\n     * Sets the constructor of the property.\n     * Optional with ReflectDecorators.\n     */\n    constructor?: Function|TypeDescriptor;\n\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted if the property is uninitialized/undefined. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name. */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that a property is part of the object when serializing, with additional options.\n * Omitting the 'constructor' option requires ReflectDecorators and that the property type is always explicitly declared.\n * @param options Additional options.\n */\nexport function jsonMember<TFunction extends Function>(options: IJsonMemberOptions): PropertyDecorator;\n\n/**\n * Specifies that a property is part of the object when serializing.\n * This call signature requires ReflectDecorators and that the property type is always explicitly declared.\n */\nexport function jsonMember(target: Object, propertyKey: string | symbol): void;\n\nexport function jsonMember<TFunction extends Function>(optionsOrTarget?: IJsonMemberOptions | Object, propKey?: string | symbol): PropertyDecorator | void\n{\n    if (optionsOrTarget instanceof Object && (typeof propKey === \"string\" || typeof propKey === \"symbol\"))\n    {\n        const target = optionsOrTarget as Object;\n        // For error messages.\n        const decoratorName = `@jsonMember on ${nameof(target.constructor)}.${String(propKey)}`;\n\n        // jsonMember used directly, no additional information directly available besides target and propKey.\n        // Obtain property constructor through ReflectDecorators.\n        if (isReflectMetadataSupported)\n        {\n            const reflectPropCtor = Reflect.getMetadata(\"design:type\", target, propKey) as Function;\n\n            if (!reflectPropCtor)\n            {\n                logError(`${decoratorName}: could not resolve detected property constructor at runtime. ${MISSING_REFLECT_CONF_MSG}`);\n                return;\n            }\n\n            if (isSpecialPropertyType(decoratorName, reflectPropCtor))\n            {\n                return;\n            }\n\n            injectMetadataInformation(target, propKey, {\n                type: new ConcreteTypeDescriptor(reflectPropCtor),\n                key: propKey.toString(),\n                name: propKey.toString(),\n            });\n        }\n        else\n        {\n            logError(`${decoratorName}: ReflectDecorators is required if no 'constructor' option is specified.`);\n            return;\n        }\n    }\n    else\n    {\n        // jsonMember used as a decorator factory.\n        return (target: Object, _propKey: string | symbol) =>\n        {\n            let options: IJsonMemberOptions = optionsOrTarget || {};\n            let propCtor: Function|TypeDescriptor|undefined;\n            let decoratorName = `@jsonMember on ${nameof(target.constructor)}.${String(_propKey)}`; // For error messages.\n\n            if (options.hasOwnProperty(\"constructor\"))\n            {\n                if (!isValueDefined(options.constructor))\n                {\n                    logError(`${decoratorName}: cannot resolve specified property constructor at runtime.`);\n                    return;\n                }\n\n                // Property constructor has been specified. Use ReflectDecorators (if available) to check whether that constructor is correct. Warn if not.\n                // todo typedescriptor\n                if (isReflectMetadataSupported && !isSubtypeOf(options.constructor as Function, Reflect.getMetadata(\"design:type\", target, _propKey)))\n                {\n                    logWarning(`${decoratorName}: detected property type does not match 'constructor' option.`);\n                }\n\n                propCtor = options.constructor;\n            }\n            else\n            {\n                // Use ReflectDecorators to obtain property constructor.\n                if (isReflectMetadataSupported)\n                {\n                    propCtor = Reflect.getMetadata(\"design:type\", target, _propKey) as Function;\n\n                    if (!propCtor)\n                    {\n                        logError(`${decoratorName}: cannot resolve detected property constructor at runtime.`);\n                        return;\n                    }\n                }\n                else if (!options.deserializer)\n                {\n                    logError(`${decoratorName}: ReflectDecorators is required if no 'constructor' option is specified.`);\n                    return;\n                }\n            }\n\n            // todo typedescriptor\n            if (isSpecialPropertyType(decoratorName, propCtor as Function))\n            {\n                return;\n            }\n\n            let type;\n            if (propCtor)\n            {\n                type = ensureTypeDescriptor(propCtor);\n            }\n            injectMetadataInformation(target, _propKey, {\n                type,\n                emitDefaultValue: options.emitDefaultValue,\n                isRequired: options.isRequired,\n                options: extractOptionBase(options),\n                key: _propKey.toString(),\n                name: options.name || _propKey.toString(),\n                deserializer: options.deserializer,\n                serializer: options.serializer,\n            });\n        };\n    }\n}\n\nfunction isSpecialPropertyType(decoratorName: string, propCtor?: Function)\n{\n    if (propCtor === Array)\n    {\n        logError(`${decoratorName}: property is an Array. Use the jsonArrayMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    if (propCtor === Set)\n    {\n        logError(`${decoratorName}: property is a Set. Use the jsonSetMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    if (propCtor === Map)\n    {\n        logError(`${decoratorName}: property is a Map. Use the jsonMapMember decorator to`\n            + ` serialize this property.`);\n        return true;\n    }\n\n    return false;\n}\n","import { isReflectMetadataSupported, logError, MISSING_REFLECT_CONF_MSG, nameof } from \"./helpers\";\nimport { injectMetadataInformation } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\nimport { isTypelike, SetT } from \"./type-descriptor\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonSetMemberOptions extends OptionsBase\n{\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Set<T>.\n * @param elementConstructor Constructor of set elements (e.g. 'Number' for Set<number> or 'Date' for Set<Date>).\n * @param options Additional options.\n */\nexport function jsonSetMember(elementConstructor: Function, options: IJsonSetMemberOptions = {})\n{\n    return (target: Object, propKey: string | symbol) =>\n    {\n        const decoratorName = `@jsonSetMember on ${nameof(target.constructor)}.${String(propKey)}`; // For error messages.\n\n        if (!isTypelike(elementConstructor))\n        {\n            logError(`${decoratorName}: could not resolve constructor of set elements at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonSetMember' has been used on a set. Warn if not.\n        if (isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Set)\n        {\n            logError(`${decoratorName}: property is not a Set. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: SetT(elementConstructor),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n","import { nameof, logError, isReflectMetadataSupported, MISSING_REFLECT_CONF_MSG } from \"./helpers\";\nimport { injectMetadataInformation } from \"./metadata\";\nimport { extractOptionBase, OptionsBase } from \"./options-base\";\nimport { isTypelike, MapT, TypeDescriptor } from \"./type-descriptor\";\n\ndeclare abstract class Reflect\n{\n    public static getMetadata(metadataKey: string, target: any, targetKey: string | symbol): any;\n}\n\nexport interface IJsonMapMemberOptions extends OptionsBase\n{\n    /** When set, indicates that the member must be present when deserializing. */\n    isRequired?: boolean;\n\n    /** When set, a default value is emitted for each uninitialized json member. */\n    emitDefaultValue?: boolean;\n\n    /** When set, the key on the JSON that should be used instead of the class property name */\n    name?: string;\n\n    /** When set, this deserializer will be used to deserialize the member. The callee must assure the correct type. */\n    deserializer?: (json: any) => any;\n\n    /** When set, this serializer will be used to serialize the member. */\n    serializer?: (value: any) => any;\n}\n\n/**\n * Specifies that the property is part of the object when serializing.\n * Use this decorator on properties of type Map<K, V>.\n * @param keyConstructor Constructor of map keys (e.g. 'Number' for 'Map<number, Date>').\n * @param valueConstructor Constructor of map values (e.g. 'Date' for 'Map<number, Date>').\n * @param options Additional options.\n */\nexport function jsonMapMember(\n    keyConstructor: Function|TypeDescriptor,\n    valueConstructor: Function|TypeDescriptor,\n    options: IJsonMapMemberOptions = {},\n) {\n    return (target: Object, propKey: string | symbol) =>\n    {\n        const decoratorName = `@jsonMapMember on ${nameof(target.constructor)}.${String(propKey)}`; // For error messages.\n\n        if (!isTypelike(keyConstructor))\n        {\n            logError(`${decoratorName}: could not resolve constructor of map keys at runtime.`);\n            return;\n        }\n\n        if (!isTypelike(valueConstructor))\n        {\n            logError(`${decoratorName}: could not resolve constructor of map values at runtime.`);\n            return;\n        }\n\n        // If ReflectDecorators is available, use it to check whether 'jsonMapMember' has been used on a map. Warn if not.\n        if (isReflectMetadataSupported && Reflect.getMetadata(\"design:type\", target, propKey) !== Map)\n        {\n            logError(`${decoratorName}: property is not a Map. ${MISSING_REFLECT_CONF_MSG}`);\n            return;\n        }\n\n        injectMetadataInformation(target, propKey, {\n            type: MapT(keyConstructor, valueConstructor),\n            emitDefaultValue: options.emitDefaultValue,\n            isRequired: options.isRequired,\n            options: extractOptionBase(options),\n            key: propKey.toString(),\n            name: options.name || propKey.toString(),\n            deserializer: options.deserializer,\n            serializer: options.serializer,\n        });\n    };\n}\n","import { TypedJSON } from \"../parser\";\n\n/**\n * Options for the @toJson decorator.\n */\nexport interface IToJsonOptions {\n    /**\n     * When set to true it will overwrite any toJSON already existing on the prototype.\n     */\n    overwrite?: boolean;\n}\n\n/**\n * Decorator that will generate toJSON function on the class prototype that allows\n * JSON.stringify to be used instead of TypedJSON.stringify. Under the hood it will\n * simply delegate to TypedJSON.\n * By default it will throw if the prototype already has a toJSON function defined.\n * @param target the class which prototype should be modified.\n */\nexport function toJson<T extends Object>(target: Function): void;\n/**\n * Decorator factory that accepts the options interface.\n * @param options for configuring the toJSON creation.\n */\nexport function toJson<T extends Object>(options: IToJsonOptions): ((target: Function) => void);\nexport function toJson<T extends Object>(optionsOrTarget: IToJsonOptions | Function\n): ((target: Function) => void) | void {\n    if (typeof optionsOrTarget === 'function') {\n        // used directly\n        toJsonDecorator(optionsOrTarget, {});\n        return;\n    }\n    // used as a factory\n    return (target: Function) => {\n        toJsonDecorator(target, optionsOrTarget);\n    }\n}\n\nfunction toJsonDecorator<T extends Object>(target: Function, options: IToJsonOptions): void {\n    if (!options.overwrite && target.prototype.toJSON) {\n        throw new Error(`${target.name} already has toJSON defined!`);\n    }\n    target.prototype.toJSON = function () {\n        return TypedJSON.toPlainJson(this, Object.getPrototypeOf(this).constructor);\n    }\n}\n","export { TypedJSON, ITypedJSONSettings, JsonTypes, TypeResolver, TypeHintEmitter } from \"./parser\";\nexport { jsonObject } from \"./typedjson/json-object\";\nexport { jsonMember } from \"./typedjson/json-member\";\nexport { jsonArrayMember } from \"./typedjson/json-array-member\";\nexport { jsonSetMember } from \"./typedjson/json-set-member\";\nexport { jsonMapMember } from \"./typedjson/json-map-member\";\nexport { toJson } from \"./typedjson/to-json\";\nexport { ArrayT, SetT, MapT } from \"./typedjson/type-descriptor\";\n"],"sourceRoot":""}